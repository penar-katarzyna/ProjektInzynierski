#include <stdio.h>

/*
  Algorytm AES zaimplementowany na potrzeby projektu z przedmiotu Mikroprocesory II, 
  Na podstawie 
  Federal Information 
  Processing Standards Publication 197
  
  November 26, 2001
  Announcing the
  
  ADVANCED ENCRYPTION STANDARD (AES)


      Autorstwo: Piotr Skibiak, Katarzyna Penar
*/


#define byte unsigned char /* 8-bit byte*/

#define short /* short = 128 , med = 192 , long = 256  */ 

#define min_state_size 16
#define multip 1 /* if text to encode is longer then min_state_size then mult := min int >= text_size/min_state_size*/

#ifdef short
  #define KEY_len 128 /* 128 or 192 or 256*/
  #define ROUND_cnt 10
#endif

#ifdef med
  #define KEY_len 192 /* 128 or 192 or 256*/
  #define ROUND_cnt 12
#endif

#ifdef long
  #define KEY_len 256 /* 128 or 192 or 256*/
  #define ROUND_cnt 14
#endif

byte buf_in[min_state_size*multip];
byte buf_out[min_state_size*multip];

byte state[min_state_size] = {
0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
};

byte roundKey[min_state_size*(ROUND_cnt+1)] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17
};
int iteracja = 0;

/*
proby:

128
przed: 32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
po:    39 25 84 1d 02 dc 09 fb dc 11 85 97 19 6a 0b 32
klucz: 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c

192
przed: 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
po   : dda97ca4864cdfe06eaf70a0ec0d7191
klucz: 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17

256
przed: 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
po   : 8e a2 b7 ca 51 67 45 bf ea fc 49 90 4b 49 60 89 
klucz: 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f

Przykladowe klucze wejsciowe

0x2b, 0x7e, 0x15, 0x16,
0x28, 0xae, 0xd2, 0xa6, 
0xab, 0xf7, 0x15, 0x88, 
0x09, 0xcf, 0x4f, 0x3c

0x8e, 0x73, 0xb0, 0xf7, 
0xda, 0x0e, 0x64, 0x52, 
0xc8, 0x10, 0xf3, 0x2b, 
0x80, 0x90, 0x79, 0xe5, 
0x62, 0xf8, 0xea, 0xd2, 
0x52, 0x2c, 0x6b, 0x7b

0x60, 0x3d, 0xeb, 0x10, 
0x15, 0xca, 0x71, 0xbe, 
0x2b, 0x73, 0xae, 0xf0, 
0x85, 0x7d, 0x77, 0x81, 
0x1f, 0x35, 0x2c, 0x07, 
0x3b, 0x61, 0x08, 0xd7, 
0x2d, 0x98, 0x10, 0xa3, 
0x09, 0x14, 0xdf, 0xf4

*/
const byte sBox[256] = {+

   0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
   0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
   0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
   0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
   0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
   0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
   0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
   0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
   0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
   0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
   0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
   0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
   0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
   0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
   0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
   0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};


byte Inv_sBox[256] = {
  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

byte Rcon[16] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a};

void print(byte x[]){
   int i;
   for (i=0; i < 16; i++)
      printf("%02x ",x[i]);
   puts("");
}


void KeySchedule(){

    
  int b,n;
  
  switch(KEY_len)
  {
    case 128: { n = 16; b = 176; break; }
    case 192: { n = 24; b = 208; break; }
    case 256: { n = 32; b = 240; break; }
    default: printf("Key Size Incorrect");
  }

  int it = 0;

  int offset = n;

  while(offset<b)
  {

/*  
We do the following to create 4 bytes of expanded key:
We create a 4-byte temporary variable, t
We assign the value of the previous four bytes in the expanded key to t
We perform the key schedule core (see above) on t, with i as the rcon iteration value
We increment i by 1
We exclusive-OR t with the four-byte block n bytes before the new expanded key. This becomes the next 4 bytes in the expanded key
*/
    roundKey[offset]    = sBox[roundKey[offset-3] ] ^ roundKey[offset-n] ^ Rcon[it];
    roundKey[offset+1]  = sBox[roundKey[offset-2] ] ^ roundKey[offset-n+1];
    roundKey[offset+2]  = sBox[roundKey[offset-1] ] ^ roundKey[offset-n+2];
    roundKey[offset+3]  = sBox[roundKey[offset-4] ] ^ roundKey[offset-n+3];

/*  
We then do the following three times to create the next twelve bytes of expanded key:
We assign the value of the previous 4 bytes in the expanded key to t
We exclusive-OR t with the four-byte block n bytes before the new expanded key. This becomes the next 4 bytes in the expanded key
*/  
  int x,y;
    
    
    for(x = 1; x < 4; ++x)
      for(y = 0; y < 4; ++y)
        roundKey[offset+x*4+y] = roundKey[offset+x*4+y-4] ^ roundKey[offset+x*4+y-n];

    offset += 16;
    it++;

/*  
If we are processing a 256-bit key, we do the following to generate the next 4 bytes of expanded key:
We assign the value of the previous 4 bytes in the expanded key to t
We run each of the 4 bytes in t through Rijndael's S-box
We exclusive-OR t with the 4-byte block n bytes before the new expanded key. This becomes the next 4 bytes in the expanded key.
*/    
/*
If we are processing a 128-bit key, we do not perform the following steps. If we are processing a 192-bit key, we run the following steps twice. 
If we are processing a 256-bit key, we run the following steps three times:
We assign the value of the previous 4 bytes in the expanded key to t
We exclusive-OR t with the four-byte block n bytes before the new expanded key. This becomes the next 4 bytes in the expanded key    
*/
  
    if (KEY_len == 256 )
    {
      roundKey[offset]      = sBox[roundKey[offset - 4 ] ] ^ roundKey[offset - n     ];
      roundKey[offset+1]    = sBox[roundKey[offset - 3 ] ] ^ roundKey[offset - n + 1 ];
      roundKey[offset+2]    = sBox[roundKey[offset - 2 ] ] ^ roundKey[offset - n + 2 ];
      roundKey[offset+3]    = sBox[roundKey[offset - 1 ] ] ^ roundKey[offset - n + 3 ];

      for(x = 1; x < 4; ++x)
        for(y = 0; y < 4; ++y)
          roundKey[offset+x*4+y] = roundKey[offset+x*4+y-4] ^ roundKey[offset+x*4+y-n];
      offset += 16;
    }
    if (KEY_len == 192)
    {
      for(x = 0; x < 2; ++x)
        for(y = 0; y < 4; ++y)
          roundKey[offset+x*4+y] = roundKey[offset+x*4+y-4] ^ roundKey[offset+x*4+y-n];
      offset += 8;
    }
}
  /*             If we want to track a key scheduler 
  int i;
  int x,y;
    for(i = 0;i<b/16;i++)
    {
      for(x = 0; x < 4; ++x)
      {
        for(y = 0; y < 4; ++y)
        {
          printf("%02x ",roundKey[i*16+y+4*x] );
        }
        printf("\n");
      }
      printf("\n");
        
    }
  */
}


void SubBytes(){
    int i;
  for(i = 0; i<16; ++i)
    state[i] = sBox[state[i]];
}

void Rotate(byte *a, byte* b, byte* c, byte* d){
  byte tmp;
  tmp = *a;
  *a = *b;
  *b = *c;
  *c = *d;
  *d = tmp;
}

void ShiftRows(){
  int i, j;
  for(i = 0; i < 4; ++i)
    for(j = 0; j<i; ++j)
      Rotate(&state[i], &state[i+4], &state[i+8], &state[i+12]);
}

void AddRoundKey(){
  int i;
  for(i = 0; i < 16; ++i)
    state[i] ^= roundKey[i+16*iteracja];
}

byte MC_Matrix[16] = {
  2, 3, 1, 1,
  1, 2, 3, 1,
  1, 1, 2, 3,
  3, 1, 1, 2
};

byte mult(byte a, byte b) {
        byte p = 0;
        byte counter;
        byte carry;
        for (counter = 0; counter < 8; counter++) {
                if (b & 1)
                        p ^= a;
                carry = (a & 0x80);
                a <<= 1;
                if (carry)
                        a ^= 0x1B;
                b >>= 1;  
        }
        return p;
}

void multiplyColumn(byte *a0, byte *a1, byte *a2, byte *a3){
  byte b0 = *a0,
       b1 = *a1,
       b2 = *a2,
       b3 = *a3;

  *a0 = mult(b0, MC_Matrix[0])
     ^ mult(b1, MC_Matrix[1])
     ^ mult(b2, MC_Matrix[2])
     ^ mult(b3, MC_Matrix[3]);

  *a1 = mult(b0, MC_Matrix[4])
     ^ mult(b1, MC_Matrix[5])
     ^ mult(b2, MC_Matrix[6])
     ^ mult(b3, MC_Matrix[7]);

  *a2 = mult(b0, MC_Matrix[8])
     ^ mult(b1, MC_Matrix[9])
     ^ mult(b2, MC_Matrix[10])
     ^ mult(b3, MC_Matrix[11]);

  *a3 = mult(b0, MC_Matrix[12])
     ^ mult(b1, MC_Matrix[13])
     ^ mult(b2, MC_Matrix[14])
     ^ mult(b3, MC_Matrix[15]);
}

byte InvMC_Matrix[16] = {
  0x0e, 0x0b, 0x0d, 0x09,
  0x09, 0x0e, 0x0b, 0x0d,
  0x0d, 0x09, 0x0e, 0x0b,
  0x0b, 0x0d, 0x09, 0x0e
};

void Inv_multiplyColumn(byte *a0, byte *a1, byte *a2, byte *a3){
  byte b0 = *a0,
       b1 = *a1,
       b2 = *a2,
       b3 = *a3;

  *a0 = mult(b0, InvMC_Matrix[0])
     ^ mult(b1, InvMC_Matrix[1])
     ^ mult(b2, InvMC_Matrix[2])
     ^ mult(b3, InvMC_Matrix[3]);

  *a1 = mult(b0, InvMC_Matrix[4])
     ^ mult(b1, InvMC_Matrix[5])
     ^ mult(b2, InvMC_Matrix[6])
     ^ mult(b3, InvMC_Matrix[7]);

  *a2 = mult(b0, InvMC_Matrix[8])
     ^ mult(b1, InvMC_Matrix[9])
     ^ mult(b2, InvMC_Matrix[10])
     ^ mult(b3, InvMC_Matrix[11]);

  *a3 = mult(b0, InvMC_Matrix[12])
     ^ mult(b1, InvMC_Matrix[13])
     ^ mult(b2, InvMC_Matrix[14])
     ^ mult(b3, InvMC_Matrix[15]);
}

void MixColumns(){
  int i;
  for(i = 0; i < 4; ++i)
    multiplyColumn(&state[4*i], &state[4*i+1], &state[4*i+2], &state[4*i+3]);
}

void InvMixColumns(){
  int i;
  for(i = 0; i < 4; ++i)
    Inv_multiplyColumn(&state[4*i], &state[4*i+1], &state[4*i+2], &state[4*i+3]);

}

void InvShiftRows(){

  int i,j,k;
  for(i = 0; i < 4; ++i)
    for(j=0; j<i; ++j)
      for(k=0; k<3; ++k)
        Rotate(&state[i], &state[i+4], &state[i+8], &state[i+12]);
}

void InvSubBytes(){
    int i;
  for(i=0; i<16; i++)
    state[i] = Inv_sBox[state[i]];
}


int main(int argc, char** argv){

  print(state);

  KeySchedule();
  AddRoundKey();

  for(iteracja = 1; iteracja < ROUND_cnt; ++iteracja){
    SubBytes();
    ShiftRows();
    MixColumns();
   print(state);
   AddRoundKey();   
  }
  SubBytes();
  ShiftRows()
  AddRoundKey();

  print(state); /*encrypted*/

  AddRoundKey();
  InvShiftRows();
  InvSubBytes();
  for(iteracja = ROUND_cnt-1; iteracja > 0; --iteracja){
    AddRoundKey();
    InvMixColumns();
    InvShiftRows();
    InvSubBytes();
  }
  AddRoundKey();

  print(state);

  return 0;

}
